// Move bytecode v6
module f77304f0b8426e09de5799104bfbc0a0efbbdaef95b5c172fb93522a19d5ee9e.fibonacci {
use 0000000000000000000000000000000000000000000000000000000000000001::signer;


struct FibResult has key {
	fib_result: u64
}
struct Foo has drop {
	foo_field: u64
}

public add(Arg0: u64, Arg1: u64): u64 {
B0:
	0: LdU64(78)
	1: Pack[1](Foo)
	2: StLoc[2](loc0: Foo)
	3: ImmBorrowLoc[2](loc0: Foo)
	4: ImmBorrowField[0](Foo.foo_field: u64)
	5: ReadRef
	6: Ret
}
public fib(Arg0: u64): u64 {
B0:
	0: CopyLoc[0](Arg0: u64)
	1: LdU64(2)
	2: Lt
	3: BrFalse(7)
B1:
	4: LdU64(1)
	5: StLoc[1](loc0: u64)
	6: Branch(17)
B2:
	7: CopyLoc[0](Arg0: u64)
	8: LdU64(1)
	9: Sub
	10: Call fib(u64): u64
	11: MoveLoc[0](Arg0: u64)
	12: LdU64(2)
	13: Sub
	14: Call fib(u64): u64
	15: Add
	16: StLoc[1](loc0: u64)
B3:
	17: MoveLoc[1](loc0: u64)
	18: Ret
}
public foo(Arg0: u64): Foo {
B0:
	0: MoveLoc[0](Arg0: u64)
	1: Pack[1](Foo)
	2: Ret
}
init_module(Arg0: &signer) {
B0:
	0: MoveLoc[0](Arg0: &signer)
	1: LdU64(7)
	2: Call move_fib(&signer, u64)
	3: Ret
}
entry public move_fib(Arg0: &signer, Arg1: u64) {
L0:	loc2: u64
B0:
	0: CopyLoc[0](Arg0: &signer)
	1: Call signer::address_of(&signer): address
	2: StLoc[2](loc0: address)
	3: MoveLoc[1](Arg1: u64)
	4: Call fib(u64): u64
	5: StLoc[4](loc2: u64)
	6: CopyLoc[2](loc0: address)
	7: Exists[0](FibResult)
	8: Not
	9: BrFalse(15)
B1:
	10: MoveLoc[0](Arg0: &signer)
	11: MoveLoc[4](loc2: u64)
	12: Pack[0](FibResult)
	13: MoveTo[0](FibResult)
	14: Branch(24)
B2:
	15: MoveLoc[0](Arg0: &signer)
	16: Pop
	17: MoveLoc[2](loc0: address)
	18: MutBorrowGlobal[0](FibResult)
	19: StLoc[3](loc1: &mut FibResult)
	20: MoveLoc[4](loc2: u64)
	21: MoveLoc[3](loc1: &mut FibResult)
	22: MutBorrowField[1](FibResult.fib_result: u64)
	23: WriteRef
B3:
	24: Ret
}
}