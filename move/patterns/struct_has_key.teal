TODO0: come gestire la borrow

// questo preambolo è a livello di modulo e contiene tutte le costanti intere e tutti i nomi delle struct
preamble:
       intcblock 0 1 39 5 78
	   bytecblock "Nested1" "Nested2" "Nested3" "Simple"

		// TODO1: il preambolo deve chiamare una entry con callsub prima o poi
		// TODO2: emettere la txna Sender per avere il signer e passarlo come arg normale alle funzioni sia entry che non

//entry public main(Arg0: &signer)
main:
	   // #args = 1
	   proto 1 0
	0: frame_dig -1
	1: callsub moveto2
	3: frame_dig -1
	4: callsub moveto2
	5: retsub


//public moveto1(Arg0: &signer, Arg1: u64) 
moveto1:
       proto 2 0
	   // tutti gli args nel call stack frame preparati dalla proto e ci accediamo direttamente con la frame_dig alla bisogna
	   // se N = #args e I = #arg con 0 <= I < N, allora EMIT 'frame_dig -(N - I)'
	0: frame_dig -2   // arg0: &signer
	1: frame_dig -1   // arg1: u64
	2: intc_2	// 39
	3: +
	4: intc_1   // true
	5:
	   // per tradurre la Pack dobbiamo convertire in byte[] tutti i campi che sono ora nello stack
	   // per farlo, dobbiamo fare un gioco di spostamenti sullo stack che alla fine ripristinerà l'ordine originale
	   // sia N = #campi, EMIT 'unconver (N-1)' per N volte ciascuna seguita dalla conversione del datatype (itob in questo caso)   
	   uncover 1	// #campi = 2, quindi offset = 1
	   itob			// convertiamo un int in un byte[]
	   uncover 1	// offset = 1, sempre uguale
	   itob 
	   // alla fine ci ritroviamo con tutti i campi convertiti e nell'ordine giusto
	   // ora dobbiamo concatenare tutti i byte[]: bisogna emettere concat N-1 volte
	   concat 		// 1 concat perché abbiamo 2 campi
	   // ora abbiamo un unico byte[] lungo che rappresenta l'intera struct
	6: 
	   // per tradurre la MoveTo dobbiamo seppellire nello stack gli arg additionali della app_local_put
	   // il signer di Move è già sullo stack di algorand per la load di arg0 alla label 0:
	   // stack: signer, packed_struct
	   // dobbiamo seppellire solo la key
	   bytec_3		// questo 3 viene dalla MoveTo[3] ed è la costante 3 del bytecblock
	   // stack: signer, packed_struct, key
	   cover 1
	   // stack: signer, key, packed_struct
	   app_local_put
	7: retsub
}

// quando una funzione move prende un argomento di tipo &signer, in algorand diventa un argoento di tipo address (che è un byte[])
//public moveto2(Arg0: &signer = address) {
moveto2:
	   proto 1 0
	0: frame_dig -1	// arg0: &signer = address
	1: intc_3	// 5
	2: intc_0	// false
	3: uncover 1
	   itob
	   uncover 1
	   itob
	   concat
	4: intc_4	// 78
	5: uncover 1  	// nessuna conversione: basta emettere la uncover 1 e nessuna itob
	   uncover 1
	   itob     	// converte 78 in byte[]
	   concat
	6: 
	   // stack: address, packed_struct
	   bytec_0		// 0 = Nested1
	   cover 1
	   // stack: address, key, packed_struct
	   app_local_put
	7: retsub
}

//public borrow1(Arg0: address): u64 {
borrow1:
	   proto 1 1
	   load 0
	0: frame_dig -1
	1: // l'account algorand è un address; ed in move convertiamo &signer in address
	   bytec_3	// oppure un pushbytes "Simple"
	   app_local_get
	   // TODO: fare la deserializzazione
	2: store 0
	3: load 0
	4: ImmBorrowField[0](Simple.f: u64)
	5: ReadRef
	6: LdU64(1)
	7: Add
	8: CopyLoc[1](loc0: &mut Simple)
	9: MutBorrowField[0](Simple.f: u64)
	10: WriteRef
	11: MoveLoc[1](loc0: &mut Simple)
	12: ImmBorrowField[0](Simple.f: u64)
	13: ReadRef
	14: Ret
}

